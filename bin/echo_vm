#!/usr/bin/env python3

"""Usage: %prog [options] file

Runs 'file' via the echo interpreter in a Python-driver-replacement style. For
example:

    python3 echo_vm.py /tmp/example.py

This allows comparisons of echo versus the standard CPython interpreter driver
on the command line.
"""

import logging
import optparse
import os
import pdb
import sys
import types
from typing import Any

from echo import interp
from echo import interp_context
from echo import import_routines
from echo import bytecode_trace
from echo.interp_result import Result

from termcolor import cprint


def _handle_result(result: Result[Any]) -> int:
    if result.is_exception():
        cprint(str(result), color='red', file=sys.stderr)
        error = True
    else:
        error = False

    return -1 if error else 0


def main() -> int:
    parser = optparse.OptionParser(__doc__)
    parser.add_option('--log_level', choices=['DEBUG', 'INFO', 'WARNING'],
                      help='Log level to use.')
    parser.add_option('--pdb', action='store_true', default=False,
                      help='Drop into PDB on error.')
    parser.add_option('-c', default=None,
                      help='Literal text to execute.')
    parser.add_option('--dump_trace', help='Path to dump bytecode trace to.')
    opts, args = parser.parse_args()

    # Options.
    if opts.log_level:
        logging.basicConfig(level=getattr(logging, opts.log_level))

    globals_ = dict(globals())

    if opts.c:
        state = interp.InterpreterState(os.getcwd())
        module_code = compile(opts.c, '<text>', 'exec')
        ictx = interp_context.ICtx(state, interp.interp, interp.do_call)
        result = ictx.interp_callback(module_code, globals_=globals_, in_function=False,
                             name='__main__', ictx=ictx)
        return _handle_result(result)

    # Path.
    if len(args) < 1:
        parser.error('A single file argument is required')

    path, *rest = args
    sys.argv = rest

    fullpath = os.path.realpath(args[0])
    globals_['__file__'] = fullpath

    state = interp.InterpreterState(os.path.dirname(fullpath))
    state.paths = sys.path[1:] + state.paths
    fully_qualified = '__main__'

    ictx = interp_context.ICtx(state, interp.interp, interp.do_call)

    prior = os.environ.get('ECHO_DUMP_INSTS', '')
    os.environ['ECHO_DUMP_INSTS'] = ''
    #assert not import_routines.run_IMPORT_NAME('fake', 0, (), 'types', dict(globals_), ictx).is_exception()
    #assert not import_routines.run_IMPORT_NAME('fake', 0, (), 'collections', dict(globals_), ictx).is_exception()
    os.environ['ECHO_DUMP_INSTS'] = prior

    try:
        result = interp.import_path(fullpath, fully_qualified, fully_qualified,
                                    ictx)
    except Exception as e:
        if opts.pdb:
            pdb.post_mortem(e.__traceback__)
        else:
            raise

    return _handle_result(result)


if __name__ == '__main__':
    sys.exit(main())
